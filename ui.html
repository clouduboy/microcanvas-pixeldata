<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ARDUBOY SpriteEditor</title>
    <style>
      body { padding: 0; margin: 0; }
      canvas {
        border: 1px solid #999;
        background: #F0F0F0;
      }
      textarea {
        font-size: 8px;
        width: 100%;
        background: black;
        color: #aaa;
        line-height: 1.5;
        border: none;
        padding: 5px;
      }
    </style>
  </head>

  <body>
    <canvas id="draw" touch-action="none">
    </canvas>
    <textarea id="spriteoutput" contenteditable="true" rows="10" cols="80"></textarea>
    <script>
      window.bitmapdata = [/*BITMAP*/];
      window.bitmap = bitmapdata.data;

      var canvas = document.getElementById("draw");
      canvas.width = Math.min(window.innerWidth,window.innerHeight);
      canvas.height = canvas.width * (bitmapdata.h / bitmapdata.w);
      var bs = Math.floor( canvas.width / bitmapdata.w );

      var C = canvas.getContext("2d");

      function bitmap2pif(bitmap, name) {
        return (name ? "$"+name+"\n" : "") +
          bitmap.reduce(function(out,row) {
            out.push(row.join(''));
            return out;
          },[]).join('\n').replace(/0/g,'.').replace(/1/g,'#');
      }

      function pif2bitmap(pif) {
        var rows = pif.replace(/[^\.\#]+/g," ").trim().split(/\s+/g);

        var matrix = rows.map(function(s) {
          var i,
              r = [];

          for (i = 0; i < s.length; ++i) {
            r.push(s[i] === '#' ? 1 : 0);
          }

          return r;
        });

        return matrix;
      }

      function bitmap2bytes(bitmap) {
        var x,y,seg,ymax,v;
        var w = bitmap[0].length, h = bitmap.length;
        var bytes = [];

        seg = 0;
        while (seg < h) {
          for (x = 0; x < w; ++x) {
            v = 0;
            ymax = (h-seg < 8 ? h-seg : 8);

            for (y = 0; y < ymax; ++y) {
              v |= bitmap[seg+y][x] << y;
            }

            // Save byte values
            bytes.push(v);
          }

          seg += 8;
        }

        return bytes;
      }

      function bytes2bitmap(bytes,w,h) {
        // Width / height optional, assume square image
      }

      var newstate;
      function postState() {
        if (!newstate) return;

        // Image dimensions
        var w = bitmap[0].length, h = bitmap.length;

        // Create bytestream
        var bytes = bitmap2bytes(bitmap);

         // Create sprite string
        var sprite = bytes.reduce(function(sprite, v) {
          return sprite += (sprite === "" ? "" : ", ") + ( v<16 ? "0x0" : "0x" ) + v.toString(16);
        }, "");

        // Build transfer string
        var transfer = { id: bitmapdata.id, w: bitmapdata.w, h: bitmapdata.h, data: bitmap }; // TODO: use "bytes" instead

        // Update sprite data in output textarea
        document.getElementById("spriteoutput").textContent = "// w: " +bitmapdata.w+ " h: " +bitmapdata.h
          + "\nPROGMEM const unsigned char " +bitmapdata.id+ "[] = { " +sprite+ " };\n";


        console.log(bitmap2pif(bitmap, bitmapdata.id));
        console.log("Dimensions:\n", bitmapdata.w, "x", bitmapdata.h);
        console.log("Sprite data:\n", "{ " +sprite+ " }");
        console.log("Transfer data:\n",JSON.stringify(transfer));
        console.log(JSON.stringify(bitmap).length, JSON.stringify(bytes).length);


        // Reset state
        newstate = null;

        // Post bytedata
        var r = new XMLHttpRequest();

        r.open("POST", "/update");
        r.setRequestHeader("Content-Type", "application/json");
        r.onreadystatechange = function () { if (r.readyState != 4 || r.status != 200) return; };

        r.send(
          JSON.stringify(transfer)
        );
      }

      function display() {
        var x,y;
        C.clearRect(0,0,canvas.width,canvas.height);
        console.log("Displayed");

        y = 0;
        while (y < bitmapdata.h) {
          x = 0;
          while (x < bitmapdata.w) {
            if (bitmap[y][x]) {
              C.fillRect(bs*x,bs*y, bs-1,bs-1);
            } else {
              C.clearRect(bs*x,bs*y, bs-1,bs-1);
            }
            ++x;
          }
          ++y;
        }

        window.requestAnimationFrame(display);
      }

      function update() {
        // Don't update if drawing
        if (paintstate) return;

        // Post bytedata
        var r = new XMLHttpRequest();

        r.open("GET", "/get");
        r.setRequestHeader("Content-Type", "application/json");
        r.onreadystatechange = function () {
          if (r.readyState != 4 || r.status != 200) return;

          // Don't update if drawing
          if (paintstate) return;

          // Update bitmap
          update = JSON.parse (r.responseText);

          bitmap = update.data;

          // Update canvas dimensions/blocksize
          if (bitmapdata.w !== update.w || bitmapdata.h !== update.h) {
            // Update blocksize
            bs = Math.floor( canvas.width / bitmapdata.w );

            // Update canvas proportions
            canvas.height = canvas.width * (update.h / update.w);
          }

          // Store updated bitmap data
          bitmapdata = update;

          console.log("Bitmap updated:\n", bitmap2pif(bitmap));

          // Update sprite data in output textarea
          var bytes = bitmap2bytes(bitmap);
          var sprite = bytes.reduce(function(sprite, v) {
            return sprite += (sprite === "" ? "" : ", ") + ( v<16 ? "0x0" : "0x" ) + v.toString(16);
          }, "");

          document.getElementById("spriteoutput").textContent = "// w: " +update.w+ " h: " +update.h
            + "\nPROGMEM const unsigned char " +update.id+ "[] = { " +sprite+ " };\n";
         };

        r.send(
          JSON.stringify()
        );

      }

      function getDXY(x,y) {
        return { x: Math.floor(x/bs), y: Math.floor(y/bs) };
      }

      function pixelAt(x,y) {
        return {
          x: Math.floor(x/bs),
          y: Math.floor(y/bs),
          color: bitmap[ Math.floor(y/bs) ][ Math.floor(x/bs) ]
        };
      }

      var lastupdate;
      var paintstate;
      function ptrStart(e) {
        var px = pixelAt(e.clientX, e.clientY);

        // Draw or erase on whole stroke depending on pixel under finger
        // on the initial touch
        if (!paintstate) {
          paintstate = px.color ? "erase" : "paint";
        }

        ptrUpdate(e);
      }

      function ptrEnd(e) {
        lastupdate = null;

        // Reset paint state
        paintstate = null;

        // Update output
        if (newstate) {
          window.requestAnimationFrame(postState);
        }
      }

      function ptrUpdate(e) {
        var px;

        // Not drawing yet
        if (!paintstate) return;

        // Fetch pixel info under pointer
        px = pixelAt(e.clientX, e.clientY);

        // Check if crossed pixel boundaries, if not, do not do anything
        if (lastupdate && lastupdate.x == px.x && lastupdate.y == px.y ) return;

        // Update pixel under finger according to current paint state
        bitmap[px.y][px.x] = ( paintstate === "paint" ? 1 : 0 );

        // Last updated pixel
        lastupdate = px;

        newstate = 1;
      }

      canvas.addEventListener("pointerdown", ptrStart, false);
      canvas.addEventListener("pointerup",   ptrEnd, false);
      canvas.addEventListener("pointermove", ptrUpdate, false);

      document.getElementById("spriteoutput").addEventListener("click",function() {
        // Try to copy sprite to clipboard
        this.focus();
        this.select();

        console.log( document.execCommand("copy") ? "Copied to clipboard." : "Copy data to clipboard manually." );
      }, false);

      window.requestAnimationFrame(display);
      setInterval(update,1000);
      </script>
      <script src="https://code.jquery.com/pep/0.3.0/pep.js"></script>
  </body>
</html>
